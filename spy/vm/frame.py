"""
Frame object.

The Frame class contains the logic to execute the SPy IR. The core of the VM
is here.

This is a stupidly simple and infefficient VM. Tons of optimizations could be
made but, for the time being, we don't care about performance.

The code contains many assert()s to do various sanity checks at runtime, for
example that the runtime type of locals matches the declared compile time
type, or that the stack has only one element on it when we execute 'return'.

In theory, many of these properties could be verified offline by writing a
bytecode verifier, but we don't care for now. The bytecode is generated by our
codegen, so the point of the assert()s is mostly to catch bugs in it.
"""

from spy.vm.vm import SPyVM
from spy.vm.object import W_Object, W_Type, W_i32
from spy.vm.codeobject import W_CodeObject

class VarStorage:
    vm: SPyVM
    name: str
    types_w: dict[str, W_Type]
    values_w: dict[str, W_Object]

    def __init__(self, vm: SPyVM, name: str, types_w: dict[str, W_Type]) -> None:
        self.vm = vm
        self.name = name
        self.types_w = types_w
        self.values_w = {}
        for varname, w_type in types_w.items():
            # for now we know how to initialize only i32 local vars. We need
            # to think of a more generic way
            assert w_type is vm.builtins.w_i32
            self.values_w[varname] = W_i32(0)

    def __repr__(self) -> str:
        return f'<VarStorage {self.name}>'

    def set(self, name: str, w_value: W_Object) -> None:
        # the invariant is that the produced bytecode should be type safe and
        # never try to set/get a variable with the wrong type. That's why we
        # have asserts instead of real exceptions.
        w_type = self.types_w[name]
        pyclass = self.vm.unwrap(w_type)
        assert isinstance(w_value, pyclass)
        self.values_w[name] = w_value

    def get(self, name: str) -> W_Object:
        assert name in self.types_w
        assert name in self.values_w
        return self.values_w[name]


class Frame:
    vm: SPyVM
    w_code: W_CodeObject
    pc: int  # program counter
    stack: list[W_Object]
    locals: VarStorage

    def __init__(self, vm: SPyVM, w_code: W_Object, globals: VarStorage = None) -> None:
        assert isinstance(w_code, W_CodeObject)
        self.vm = vm
        self.w_code = w_code
        if globals is None:
            self.globals = VarStorage(vm, 'globals', {})
        else:
            self.globals = globals
        self.locals = VarStorage(vm, f"'{w_code.name} locals'", w_code.locals_w_types)
        self.pc = 0
        self.stack = []

    def push(self, w_value: W_Object) -> None:
        assert isinstance(w_value, W_Object)
        self.stack.append(w_value)

    def pop(self) -> W_Object:
        return self.stack.pop()

    def init_arguments(self, args_w: list[W_Object]) -> None:
        assert len(args_w) == len(self.w_code.params)
        for varname, w_arg in zip(self.w_code.params, args_w):
            self.locals.set(varname, w_arg)

    def run(self, args_w: list[W_Object]) -> W_Object:
        self.init_arguments(args_w)
        while True:
            op = self.w_code.body[self.pc]
            # 'return' is special, handle it explicitly
            if op.name == 'return':
                assert len(self.stack) == 1
                return self.pop()
            else:
                meth_name = f'op_{op.name}'
                meth = getattr(self, meth_name, None)
                if meth is None:
                    raise NotImplementedError(meth_name)
                meth(*op.args)
                self.pc += 1

    def op_i32_const(self, w_const: W_Object) -> None:
        assert isinstance(w_const, W_i32)
        self.push(w_const)

    def op_i32_add(self) -> None:
        w_b = self.pop()
        w_a = self.pop()
        assert isinstance(w_a, W_i32)
        assert isinstance(w_b, W_i32)
        a = self.vm.unwrap(w_a)
        b = self.vm.unwrap(w_b)
        w_c = self.vm.wrap(a + b)
        self.push(w_c)

    def op_i32_sub(self) -> None:
        w_b = self.pop()
        w_a = self.pop()
        assert isinstance(w_a, W_i32)
        assert isinstance(w_b, W_i32)
        a = self.vm.unwrap(w_a)
        b = self.vm.unwrap(w_b)
        w_c = self.vm.wrap(a - b)
        self.push(w_c)

    def op_local_get(self, varname: str) -> None:
        w_value = self.locals.get(varname)
        self.push(w_value)

    def op_local_set(self, varname: str) -> None:
        w_value = self.pop()
        self.locals.set(varname, w_value)

    def op_global_get(self, varname: str) -> None:
        w_value = self.globals.get(varname)
        self.push(w_value)

    def op_global_set(self, varname: str) -> None:
        w_value = self.pop()
        self.globals.set(varname, w_value)
