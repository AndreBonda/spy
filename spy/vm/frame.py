"""
Frame object.

The Frame class contains the logic to execute the SPy IR. The core of the VM
is here.

This is a stupidly simple and infefficient VM. Tons of optimizations could be
made but, for the time being, we don't care about performance.

The code contains many assert()s to do various sanity checks at runtime, for
example that the runtime type of locals matches the declared compile time
type, or that the stack has only one element on it when we execute 'return'.

In theory, many of these properties could be verified offline by writing a
bytecode verifier, but we don't care for now. The bytecode is generated by our
codegen, so the point of the assert()s is mostly to catch bugs in it.
"""

from typing import TYPE_CHECKING, Any
from spy.fqn import FQN
from spy.location import Loc
from spy.errors import SPyRuntimeAbort, SPyTypeError
from spy.vm.object import W_Object, W_Type, W_i32, W_bool
from spy.vm.str import W_str
from spy.vm.codeobject import W_CodeObject, OpCode
from spy.vm.varstorage import VarStorage
from spy.vm.function import W_Func, W_UserFunc, W_FuncType
from spy.vm import helpers
if TYPE_CHECKING:
    from spy.vm.vm import SPyVM


class Frame:
    vm: 'SPyVM'
    w_func: W_UserFunc
    w_code: W_CodeObject
    pc: int  # program counter
    stack: list[W_Object]
    locals: VarStorage
    labels: dict[str, int] # name -> pc

    def __init__(self, vm: 'SPyVM', w_func: W_UserFunc) -> None:
        assert isinstance(w_func, W_UserFunc)
        self.vm = vm
        self.w_func = w_func
        self.w_code = w_func.w_code
        self.locals = VarStorage(vm, f"'{self.w_code.name} locals'")
        self.pc = 0
        self.stack = []
        self.labels = {}
        self.init_labels()

    def init_labels(self) -> None:
        for pc, op in enumerate(self.w_code.body):
            if op.name == 'label':
                l = op.args[0]
                assert l not in self.labels, f'duplicate label: {l}'
                self.labels[l] = pc

    def jump(self, LABEL: str) -> None:
        self.pc = self.labels[LABEL]

    def push(self, w_value: W_Object) -> None:
        assert isinstance(w_value, W_Object)
        self.stack.append(w_value)

    def pop(self) -> W_Object:
        return self.stack.pop()

    def init_arguments(self, args_w: list[W_Object]) -> None:
        for w_arg in reversed(args_w):
            self.push(w_arg)

    def typecheck_local(self, got_loc: Loc, varname: str,
                        w_got: W_Object) -> None:
        w_type = self.locals.types_w[varname]
        if self.vm.is_compatible_type(w_got, w_type):
            return
        err = SPyTypeError('mismatched types')
        got = self.vm.dynamic_type(w_got).name
        exp = w_type.name
        exp_loc = self.locals.locs[varname]
        err.add('error', f'expected `{exp}`, got `{got}`', loc=got_loc)
        if varname == '@return':
            because = 'because of return type'
            err.add('note', f'expected `{exp}` {because}', loc=exp_loc)
        raise err

    def run(self, args_w: list[W_Object]) -> W_Object:
        self.init_arguments(args_w)
        while True:
            op = self.w_code.body[self.pc]
            # 'return' is special, handle it explicitly
            if op.name == 'return':
                n = len(self.stack)
                assert n == 1, f'Wrong stack size upon return: {n}'
                w_result = self.pop()
                self.typecheck_local(op.loc, '@return', w_result)
                return w_result
            else:
                meth_name = f'op_{op.name}'
                meth = getattr(self, meth_name, None)
                if meth is None:
                    raise NotImplementedError(meth_name)
                meth(op, *op.args)
                self.pc += 1
                assert self.pc < len(self.w_code.body), 'no return?'

    def op_abort(self, op: OpCode, message: str) -> None:
        raise SPyRuntimeAbort(message)

    def op_label(self, op: OpCode, name: str) -> None:
        assert self.labels[name] == self.pc

    def op_line(self, op: OpCode, lineno: int) -> None:
        pass

    def op_mark_if_then(self, op: OpCode, IF: str) -> None:
        pc_if = self.labels[IF]
        assert self.w_code.body[pc_if + 1].match('br_if', ...)
    op_mark_if_then_else = op_mark_if_then

    def op_mark_while(self, op: OpCode, WHILE: str, IF: str, END: str) -> None:
        pc_if = self.labels[IF]
        pc_end = self.labels[END]
        assert self.w_code.body[pc_if + 1].match('br_while_not', ...)
        assert self.w_code.body[pc_end - 1].match('br', WHILE)

    def op_pop_and_discard(self, op: OpCode) -> None:
        self.pop()

    def op_load_const(self, op: OpCode, w_const: W_Object) -> None:
        self.push(w_const)

    def _exec_op_i32_binop(self, func: Any) -> None:
        w_b = self.pop()
        w_a = self.pop()
        assert isinstance(w_a, W_i32)
        assert isinstance(w_b, W_i32)
        a = self.vm.unwrap(w_a)
        b = self.vm.unwrap(w_b)
        c = func(a, b)
        w_c = self.vm.wrap(c)
        self.push(w_c)

    def op_i32_add(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a + b)

    def op_i32_sub(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a - b)

    def op_i32_mul(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a * b)

    def op_i32_eq(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a == b)

    def op_i32_neq(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a != b)

    def op_i32_lt(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a < b)

    def op_i32_lte(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a <= b)

    def op_i32_gt(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a > b)

    def op_i32_gte(self, op: OpCode) -> None:
        self._exec_op_i32_binop(lambda a, b: a >= b)

    def op_declare_local(self, op: OpCode, varname: str) -> None:
        w_type = self.pop()
        assert isinstance(w_type, W_Type) # this should be a proper error
        self.locals.declare(op.loc, varname, w_type)

    def op_load_local(self, op: OpCode, varname: str) -> None:
        w_value = self.locals.get(varname)
        self.push(w_value)

    def op_store_local(self, op: OpCode, varname: str) -> None:
        w_value = self.pop()
        self.locals.set(varname, w_value)

    def op_load_global(self, op: OpCode, fqn: FQN) -> None:
        w_value = self.vm.lookup_global(fqn)
        assert w_value is not None
        self.push(w_value)

    def op_load_nonlocal(self, op: OpCode, varname: str) -> None:
        # XXX for now we assume it's a builtin
        fqn = FQN(modname='builtins', attr=varname)
        w_value = self.vm.lookup_global(fqn)
        assert w_value is not None
        self.push(w_value)

    def op_store_global(self, op: OpCode, fqn: FQN) -> None:
        w_value = self.pop()
        self.vm.store_global(fqn, w_value)

    def _pop_args(self, argcount: int) -> list[W_Object]:
        args_w = []
        for i in range(argcount):
            args_w.append(self.pop())
        args_w.reverse()
        return args_w

    def op_call_global(self, op: OpCode, fqn: FQN, argcount: int) -> None:
        w_func = self.vm.lookup_global(fqn)
        assert isinstance(w_func, W_Func)
        return self._op_call(w_func, argcount)

    def _op_call(self, w_func: W_Func, argcount: int) -> None:
        args_w = self._pop_args(argcount)
        w_res = self.vm.call_function(w_func, args_w)
        self.push(w_res)

    def op_call_helper(self, op: OpCode, funcname: str, argcount: int) -> None:
        helper_func = helpers.get(funcname)
        args_w = self._pop_args(argcount)
        w_res = helper_func(self.vm, *args_w)
        self.push(w_res)

    def op_br(self, op: OpCode, TARGET: str) -> None:
        self.jump(TARGET)

    def op_br_if(self, op: OpCode, THEN: str, ELSE: str, ENDIF: str) -> None:
        w_cond = self.pop()
        assert isinstance(w_cond, W_bool)
        if self.vm.is_True(w_cond):
            self.jump(THEN)
        else:
            self.jump(ELSE)

    def op_br_while_not(self, op: OpCode, END: str) -> None:
        w_cond = self.pop()
        assert isinstance(w_cond, W_bool)
        if self.vm.is_False(w_cond):
            self.jump(END)

    def op_dup(self, op: OpCode) -> None:
        w_value = self.pop()
        self.push(w_value)
        self.push(w_value)

    def op_make_func_type(self, op: OpCode, argnames: tuple[str, ...]) -> None:
        n = len(argnames)
        w_restype = self.pop()
        argtypes_w = self._pop_args(n)
        d = dict(zip(argnames, argtypes_w))
        w_functype = W_FuncType.make(
            w_restype = w_restype,
            color='red', # XXX is this correct?
            **d)
        self.push(w_functype)

    def op_make_function(self, op: OpCode) -> None:
        w_code = self.pop()
        w_functype = self.pop()
        # XXX this FQN is wrong
        fqn = FQN(modname=f'{self.w_code.name}<inner>', attr=w_code.name)
        w_func = W_UserFunc(fqn, w_functype, w_code)
        self.push(w_func)
