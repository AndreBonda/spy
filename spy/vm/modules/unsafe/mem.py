from typing import TYPE_CHECKING, Annotated
from spy.errors import WIP
from spy.vm.b import B
from spy.vm.primitive import W_I32, W_Dynamic
from spy.vm.w import W_Type, W_Object
from spy.vm.struct import W_StructType, W_Struct
from . import UNSAFE
from .ptr import W_Ptr, w_make_ptr_type, W_PtrType
from .misc import sizeof

if TYPE_CHECKING:
    from spy.vm.vm import SPyVM

@UNSAFE.builtin_func(color="blue")
def w_gc_alloc(vm: "SPyVM", w_T: W_Type) -> W_Dynamic:
    w_ptrtype = vm.fast_call(w_make_ptr_type, [w_T])  # unsafe::ptr[i32]
    assert isinstance(w_ptrtype, W_PtrType)
    ITEMSIZE = sizeof(w_T)

    # unsafe::ptr[i32]::gc_alloc
    #
    # this is a special builtin function, its C equivalent is automatically
    # generated by c.Context.new_ptr_type
    @vm.register_builtin_func(w_ptrtype.fqn, "gc_alloc")
    def w_fn(vm: "SPyVM", w_n: W_I32) -> Annotated[W_Ptr, w_ptrtype]:
        n = vm.unwrap_i32(w_n)
        size = ITEMSIZE * n
        addr = vm.ll.call("spy_gc_alloc_mem", size)
        return W_Ptr(w_ptrtype, addr, n)  # type: ignore
    return w_fn


@UNSAFE.builtin_func(color="blue")
def w_mem_read(vm: "SPyVM", w_T: W_Type) -> W_Dynamic:
    T = Annotated[W_Object, w_T]
    # unsafe::mem_read[T]
    @vm.register_builtin_func("unsafe", "mem_read", [w_T.fqn])
    def w_mem_read_T(vm: "SPyVM", w_addr: W_I32) -> T:
        addr = vm.unwrap_i32(w_addr)
        return generic_mem_read(vm, addr, w_T)
    return w_mem_read_T


@UNSAFE.builtin_func(color="blue")
def w_mem_write(vm: "SPyVM", w_T: W_Type) -> W_Dynamic:
    T = Annotated[W_Object, w_T]
    # unsafe::mem_write[T]
    @vm.register_builtin_func("unsafe", "mem_write", [w_T.fqn])
    def w_mem_write_T(vm: "SPyVM", w_addr: W_I32, w_val: T) -> None:
        addr = vm.unwrap_i32(w_addr)
        generic_mem_write(vm, addr, w_T, w_val)
    return w_mem_write_T


def generic_mem_read(vm: "SPyVM", addr: int, w_T: W_Type) -> W_Object:
    if w_T is B.w_i32:
        return vm.wrap(vm.ll.mem.read_i32(addr))
    elif w_T is B.w_f64:
        return vm.wrap(vm.ll.mem.read_f64(addr))
    elif isinstance(w_T, W_PtrType):
        v_addr, v_length = vm.ll.mem.read_ptr(addr)
        return W_Ptr(w_T, v_addr, v_length)
    elif isinstance(w_T, W_StructType):
        # read the struct by value, field by field
        values_w = {}
        for fname, w_field in w_T.fields_w.items():
            offset = w_T.offsets[fname]
            values_w[fname] = generic_mem_read(vm, addr+offset, w_field.w_T)
        return W_Struct(w_T, values_w)
    else:
        raise WIP(f"Cannot read memory of type `{w_T.fqn.human_name}`")


def generic_mem_write(vm: "SPyVM", addr: int,
                      w_T: W_Type, w_val: W_Object) -> None:
    if w_T is B.w_i32:
        v = vm.unwrap_i32(w_val)
        vm.ll.mem.write_i32(addr, v)
    elif w_T is B.w_f64:
        v = vm.unwrap_f64(w_val)
        vm.ll.mem.write_f64(addr, v)
    elif isinstance(w_T, W_PtrType):
        assert isinstance(w_val, W_Ptr)
        vm.ll.mem.write_ptr(addr, w_val.addr, w_val.length)
    elif isinstance(w_T, W_StructType):
        assert isinstance(w_val, W_Struct)
        # write the struct by value, field by field
        for fname, w_field in w_T.fields_w.items():
            offset = w_T.offsets[fname]
            generic_mem_write(
                vm,
                addr + offset,
                w_field.w_T,
                w_val.values_w[fname]
            )
    else:
        raise WIP(f"Cannot write memory of type `{w_T.fqn.human_name}`")
