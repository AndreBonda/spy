"""
SPy list module

A generic dynamic array implementation similar to Python's list.
"""

from unsafe import gc_alloc, ptr

@blue.generic
def List(T):

    @struct
    class ListData:
        length: i32
        capacity: i32
        items: ptr[T]

    @struct
    class list_iterator:
        lst: ptr[ListData]
        i: i32

        def __next__(self: list_iterator) -> list_iterator:
            return list_iterator(self.lst, self.i + 1)

        def __item__(self: list_iterator) -> T:
            return self.lst.items[self.i]

        def __continue_iteration__(self: list_iterator) -> bool:
            return self.i < self.lst.length

    @typelift
    class _ListImpl:
        __ll__: ptr[ListData]

        def __new__() -> _ListImpl:
            data = gc_alloc(ListData)(1)
            data.length = 0
            data.capacity = 4
            data.items = gc_alloc(T)(4)
            return _ListImpl.__lift__(data)

        def append(self: _ListImpl, item: T) -> None:
            ll = self.__ll__
            if ll.length >= ll.capacity:
                old_capacity = ll.capacity
                new_capacity = old_capacity * 2
                new_items = gc_alloc(T)(new_capacity)

                i = 0
                while i < ll.length:
                    new_items[i] = ll.items[i]
                    i = i + 1

                ll.items = new_items
                ll.capacity = new_capacity

            ll.items[ll.length] = item
            ll.length = ll.length + 1

        def __len__(self: _ListImpl) -> i32:
            return self.__ll__.length

        def __getitem__(self: _ListImpl, i: i32) -> T:
            ll = self.__ll__
            if i >= ll.length:
                raise IndexError
            return ll.items[i]

        def __setitem__(self: _ListImpl, i: i32, value: T) -> None:
            ll = self.__ll__
            if i >= ll.length:
                raise IndexError
            ll.items[i] = value

        def pop(self: _ListImpl) -> T:
            ll = self.__ll__
            if ll.length == 0:
                raise IndexError
            ll.length = ll.length - 1
            return ll.items[ll.length]

        def insert(self: _ListImpl, i: i32, item: T) -> None:
            ll = self.__ll__
            if i > ll.length:
                i = ll.length
            if i < 0:
                i = 0

            if ll.length >= ll.capacity:
                old_capacity = ll.capacity
                new_capacity = old_capacity * 2
                new_items = gc_alloc(T)(new_capacity)

                j = 0
                while j < ll.length:
                    new_items[j] = ll.items[j]
                    j = j + 1

                ll.items = new_items
                ll.capacity = new_capacity

            j = ll.length
            while j > i:
                ll.items[j] = ll.items[j - 1]
                j = j - 1

            ll.items[i] = item
            ll.length = ll.length + 1

        def clear(self: _ListImpl) -> None:
            ll = self.__ll__
            ll.length = 0

        def __fastiter__(self: _ListImpl) -> list_iterator:
            return list_iterator(self.__ll__, 0)

    return _ListImpl
