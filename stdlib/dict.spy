from hash import hash
from unsafe import gc_alloc, ptr


DKIX_EMPTY = 0
# DKIX_DUMMY = 2 ** 32 - 1
DKIX_DUMMY = 1 << 32 - 1
# DKIX_ERROR = 2 ** 32 - 2
DKIX_ERROR = 1 << 32 - 2
# DKIX_KEY_CHANGED = 2 ** 32 - 3
DKIX_KEY_CHANGED = 1 << 32 - 3

MIN_LOG_SIZE = 6
MAX_LOG_SIZE = 31
MAX_FILL_RATIO = 2 / 3


@blue.generic
def dict(Key, Value):
    hash_key = hash[Key]

    @struct
    class Entry:
        # empty: bool
        empty: i32
        key: Key
        value: Value


    @struct
    class DictData:
        index: ptr[i32]
        log_size: i32  # capacity
        length: i32  # number of items stored
        entries: ptr[Entry]

    def new_index(log_size: i32) -> ptr[i32]:
        # assert MIN_LOG_SIZE <= log_size <= MAX_LOG_SIZE
        index = gc_alloc(i32)(1 << log_size)
        i = 0
        while i < 1 << log_size:
            index[i] = DKIX_EMPTY
            i += 1
        return index

    def new_entries(log_size: i32) -> ptr[Entry]:
        entries = gc_alloc(Entry)(1 << log_size)
        i = 0
        while i < 1 << log_size:
            entries[i].empty = 1
            i += 1
        return entries

    def capacity(data: ptr[DictData]) -> i32:
        return 1 << data.log_size

    def mask(data: ptr[DictData]) -> i32:
        return 1 << data.log_size - 1

    def distance_0(data: ptr[DictData], key: Key) -> i32:
        # the first slot in the index to probe when looking up key
        return hash_key(key) & mask(data)

    # def get_entry_at(self: _dict, position: i32) -> Entry:
    #     data: DictData = self.__ll__
    #     return data.entries[position]

    def lookup(self: _dict, key: Key) -> i32:
        data: ptr[DictData] = self.__ll__
        hash_lookup = hash_key(key)  # might raise exception
        d0 = distance_0(data, key)
        distance = 0
        while distance < capacity(data):
            position = (d0 + distance) % capacity(data)
            ix = data.index[position]
            if ix == DKIX_EMPTY:
                return DKIX_EMPTY
            if ix == DKIX_DUMMY:
                # continue
                pass
            else:
                # entry = get_entry_at(self, ix)
                entry_empty = data.entries[ix].empty
                # if not entry_empty:
                    # [Antonio]: another hard-to-read error. I think it says there's no `not`?
                    #   File "/Users/dp/repos/spy/spy/vm/modules/operator/__init__.py", line 115, in OP_unary_from_token
                    #     return _unary_from_token[token]
                    #            ~~~~~~~~~~~~~~~~~^^^^^^^
                    # KeyError: 'not'
                if entry_empty:
                    pass
                else:
                    entry_key = data.entries[ix].key
                    # continue (I'd rather remove the `not` and use `continue` here)
                    hash_entry = hash_key(entry_key)  # might raise exception
                    if hash_entry == hash_lookup:
                        # if entry_key is key:
                        #     return ix
                        # WIP: Operator not implemented yet: is
                        cmp = entry_key == key  # might raise exception
                        if cmp:
                            return ix
            distance += 1
        return DKIX_EMPTY

    def insert_entry(entries: ptr[Entry], ix: i32, key: Key, value: Value) -> None:
        entries[ix].key = key
        entries[ix].value = value
        entries[ix].empty = 0

    def insert_index_node(data: ptr[DictData], entry_ix: i32, key: Key) -> None:
        d0 = distance_0(data, key)
        distance = 0
        while distance < capacity(data):
            position = (d0 + distance) % capacity(data)
            ix = data.index[position]
            if ix == DKIX_EMPTY:
                data.index[position] = entry_ix
                return
            distance += 1
        raise Exception("aargh!")
        # must not loop through the entire index without finding a free slot

    def insert(self: _dict, key: Key, value: Value) -> None:
        data: ptr[DictData] = self.__ll__
        # entry = data.entries[data.length]
        l = data.length + 1
        # data.length += 1
        data.length = l
        insert_entry(data.entries, l, key, value)
        insert_index_node(data, l, key)

    def resize_entries(data: ptr[DictData], new_log_size: i32) -> ptr[Entry]:
        entries = new_entries(new_log_size)
        i = 0
        while i <= data.length:
            entry = data.entries[i]
            if entry.empty:
                pass
            else:
                insert_entry(entries, i, entry.key, entry.value)
            i += 1
        return entries

    def build_index_from_data_entries(data: ptr[DictData]) -> None:
        i = 0
        while i <= data.length:
            entry = data.entries[i]
            if entry.empty:
                pass
            else:
                insert_index_node(data, i, entry.key)
            i += 1

    def resize(self: _dict) -> None:
        # The resize operation never decreases the memory used by dict;
        # i.e., we always resize to double the size of dict.
        # This follows the CPython implementation.
        data: ptr[DictData] = self.__ll__
        new_log_size = data.log_size + 1
        data.log_size = new_log_size
        data.entries = resize_entries(data, new_log_size)
        data.index = new_index(new_log_size)
        build_index_from_data_entries(data)

    @typelift
    class _dict:
        __ll__: ptr[DictData]

        def __new__() -> _dict:
            data = gc_alloc(DictData)(1)
            data.log_size = MIN_LOG_SIZE
            data.length = 0
            data.index = new_index(data.log_size)
            data.entries = new_entries(data.log_size)
            return _dict.__lift__(data)

        def __getitem__(self: _dict, key: Key) -> Value:
            data: ptr[DictData] = self.__ll__
            ix = lookup(self, key)
            if ix == DKIX_EMPTY:
                # raise KeyError(key)
                # [Antonio]: no KeyError? :(
                # NameError: name `KeyError` is not defined
                #    --> /Users/dp/repos/spy/stdlib/dict.spy:184:23
                # 184 |                 raise KeyError(key)
                #     |                       |______| not found in this scope
                raise Exception("KeyError")
            return data.entries[ix].value

        def __setitem__(self: _dict, key: Key, value: Value) -> None:
            data: ptr[DictData] = self.__ll__
            ix = lookup(self, key)
            if ix == DKIX_EMPTY:
                insert(self, key, value)
                if data.length >= capacity(data) * MAX_FILL_RATIO:
                    resize(self)
            else:
                # entry = get_entry_at(self, ix)
                # assert not entry.empty
                # entry.value = value
                data.entries[ix].value = value

        def __delitem__(self: _dict, key: Key) -> None:
            pass

        def __len__(self: _dict) -> i32:
            data: ptr[DictData] = self.__ll__
            return data.length


    return _dict
